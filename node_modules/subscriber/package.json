{
  "_args": [
    [
      {
        "raw": "subscriber",
        "scope": null,
        "escapedName": "subscriber",
        "name": "subscriber",
        "rawSpec": "",
        "spec": "latest",
        "type": "tag"
      },
      "/Users/stonesun/Project/eggServer/egg-example"
    ]
  ],
  "_from": "subscriber@latest",
  "_id": "subscriber@0.3.1",
  "_inCache": true,
  "_location": "/subscriber",
  "_npmUser": {
    "name": "deitch",
    "email": "avi@deitcher.net"
  },
  "_npmVersion": "1.3.5",
  "_phantomChildren": {},
  "_requested": {
    "raw": "subscriber",
    "scope": null,
    "escapedName": "subscriber",
    "name": "subscriber",
    "rawSpec": "",
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/subscriber/-/subscriber-0.3.1.tgz",
  "_shasum": "a98bea8067167d09fc270f33f0134be0106215ea",
  "_shrinkwrap": null,
  "_spec": "subscriber",
  "_where": "/Users/stonesun/Project/eggServer/egg-example",
  "author": {
    "name": "Avi Deitcher",
    "email": "avi@deitcher.net"
  },
  "bugs": {
    "url": "https://github.com/deitch/subscriber/issues"
  },
  "dependencies": {
    "async": "0.2.x",
    "lodash": ">=1.3.1"
  },
  "description": "Subscriber Module",
  "devDependencies": {
    "express": "3.x",
    "mocha": "1.x",
    "searchjs": "0.x",
    "should": "1.x",
    "supertest": "0.x"
  },
  "directories": {},
  "dist": {
    "shasum": "a98bea8067167d09fc270f33f0134be0106215ea",
    "tarball": "https://registry.npmjs.org/subscriber/-/subscriber-0.3.1.tgz"
  },
  "engines": [
    "node >= 0.8"
  ],
  "homepage": "https://github.com/deitch/subscriber#readme",
  "keywords": [
    "subscribe",
    "subscription",
    "express",
    "node",
    "nodejs",
    "authorization",
    "plans"
  ],
  "main": "./lib/subscriber.js",
  "maintainers": [
    {
      "name": "deitch",
      "email": "avi@deitcher.net"
    }
  ],
  "name": "subscriber",
  "optionalDependencies": {},
  "readme": "# subscriber\n\n\n##Overview\nSubscriber is ***the*** subscriptions manager for [nodejs](http://nodejs.org) and [expressjs](http://expressjs.com) apps!\n\n````JavaScript\nvar subscriber = require('subscriber'), express = require('express'), app = express(), db = require('./myDbSetup');\n\napp.use(subscriber.init({db:db,timeout:60}));\n\napp.listen(3000);\n````\n\nDone! You now have a subscription management service filtering every request and deciding whether or not it fits within the requestor's plan or subscription.\n\n## Features\n\n* Multiple plan types\n* Free-form plan names: name a plan whatever you want!\n* Control reads, writes, creates, updates, deletes\n* Works naturally with REST\n* Works with any REST resource name\n* Paid and free plans\n* Free trials\n* Plan expiry built-in\n* Completely backend database agnostic\n* Cache plans with controllable timeout\n\n\n##Installation\n\n````\nnpm install subscriber\n````\n\nDoesn't get easier than that!\n\n\n## Planning your plans\nWhile installation is easy, you probably want to spend a *bit* of time before using subscriber to think about how you want to offer plans and what you want to restrict. After all, subscriber is responsible for enforcing *your* plan restrictions, not deciding what they should be. For that, please see [the future](http://en.wikipedia.org/wiki/Skynet_%28Terminator%29). \n\n### Plan types\nYou will usually have one or more plan \"types\", each of which has a name and restrictions. Let's create an example of a consulting client management service, with three tiers:\n\n* Tier \"free\" allows up to 3 clients\n* Tier \"regular\" allows up to 10 clients\n* Tier \"pro\" allows up to 30 clients\n\nEach login will be affiliated with one plan, describing what it can do. So user \"joe\" logging in will retrieve that he is on plan \"regular\" and thus be allowed to maintain up to 10 clients.\n\nYou need to decide in advance (but can change at any time):\n\n1. The names of your plans\n2. The limits of your plans\n\n\n### Free trials\nOften, Web services offer a time-limited free trial of paid plans (since offering free trials of free plans really does not make much sense!). For example, if we are offering three paid plans - bronze, silver, gold - we may want to allow a new user to try any plan for 14 days, as long as s/he has never tried a plan before.\n\nsubscriber allows you to support time-limited free trials, as well as arbitrarily extend the length of a particular trial. You do need to decide in advance (but can change at any time):\n\n1. Which plans get a free trial\n2. The default length of a free trial\n\n### Plan expiry\nIf you want, you can have subscriber enforce expiry dates for plans, by indicating on a user when the plan expires. Just say, \"this plan expires on date X\", and subscriber will enforce the user not being on the plan after that date.\n\n\n## User States\nThis section lists all of the potential states that a user can be in, assuming the user has an account.\n\n* No plan: User is not on any plan at all\n* Regular plan unexpired: User is on a normal plan, which either has an expiry date in the future or no expiry date\n* Regular plan expired: User is on an expired plan, i.e. a plan with an expiry date in the past\n* Trial plan unexpired: User is on a free trial of a normal plan, which has an expiry date in the future\n* Trial plan expired with fallback: User was on a free trial of a plan; the free trial expired, leaving the user to fall back to the defined fallback plan.\n* Trial plan expired with no fallback: User was on a free trial of a plan; the free trial expired, no fallback was defined, leaving the user no plan to fall back upon. This is equivalent to \"No plan\", except that the system knows the user already *had* a free trial.\n* Trial plan extended: User was on a free trial of a plan, which would have expired, but an administrator extended the expiry date *for this user*.\n\n\n##Usage\n### What does it provide?\nsubscriber provides control over requests based on different *subscriptions*. For example, if your Web service, say a consulting client management service, has three tiers: free, regular, pro. Free users get to have up to 3 clients, regular users up to 10 and pro up to 30. You want to ensure that each tier of users gets restricted to the amount they are allowed.\n\nsubscriber can also handle free trials. You may want to give users a free trial for 14 days (or maybe 25 days) of one or more of your paid plans, but only once.\n\nsubscriber controls each and every access to make sure it conforms with the subscriber's subscription rights.\n\n\n#### What about authorization?\nsubscription is related to security, but it isn't about security. *Security Authorization* is concerned with whether or not user \"john\" has the security right to read user \"sally\"'s clients. *Subscription* is about whether or not user \"john\" can create another client, even one he normally would be permitted, because he hasn't yet paid for a plan that lets him.\n\nIt is really *really* **really** good to keep subscription and security authorization separate. If you make a mistake with subscriptions, well, you accidentally gave away a little something too much for free, or didn't let a customer do something for which he paid; he will call support to complain, I guarantee it!\n\nIf you make a mistake with security, user \"john\" can see the private information of user \"sally\" or even change her information. Chances are \"john\" and \"sally\" are leaving you and never coming back! And if it makes the press, well, so is everyone else.\n\n### What does it look like?\n\n````JavaScript\nvar express = require('express'), app = express(), subscriber = require('subscriber');\n\n// set up my database\ndb = dbSetUp();\napp.use(mySecurityPackage);\napp.use(subscriber.init({db:db,timeout:60}));\napp.use(app.router);\n\napp.listen(3000);\n````\n\nPersonally, I would always recommend your security authorization package, e.g. [cansecurity](http://github.com/deitch/cansecurity), come *before* subscriber. You are better off preventing someone from doing something they would *never* be allowed to do before bothering to check their plan.\n\n\n### Getting started\n````JavaScript\nvar subscriber = require('subscriber');\n````\n\nThat shouldn't surprise anyone!\n\nSo what do I do with `subscriber` once I have `require`d it?\n\n````JavaScript\napp.use(subscriber.init(config)); // returns subscriber, so you can chain\n````\n\nAnd what exactly goes in that config, anyways?\n\n* `db`: a database object. Required. See below.\n* `timeout`: how long (in minutes) to keep the list of plans around before refreshing. Optional. Defaults to 60. Set to 0 for no caching in subscriber.\n* `base`: string. Base path after which a particular resource comes. Optional. Defaults to '/'. See below.\n* `paths`: object. Paths for each resource for a plan. See below.\n\n\n### How It Works\nWhen you first initialize subscriber, it issues a request to get all of the plans, and caches them. Thus, it knows exactly how many clients are allowed under the \"bronze\" plan and how many groups under the \"premium\" plan. It keeps this cache for as long as the `timeout` in the config. The next request that comes after the timeout is expired triggers a refresh. If the timeout is 0, it never caches (at least `subscriber` doesn't).\n\n\nWith each request of any type (`GET`, `PUT`, `PATCH`, `POST`, `DELETE`), subscriber will get the user information, and compare it to the plan in the cache (refreshing if past timeout). \n\nIf the request is within the plan, `subscriber` will just call `next()`. If it is not, it will return a `403` error. The body of the error will be the plan and the item that was limited:\n\n    {reason:\"subscription\",plan:\"bronze\",limit:\"client\",maximum:5} \n\t\t\nIn the above example, the user attempted to create too many items of type client, with the plan \"bronze\", where the limit is 5.\n\n\n### db Instance\nThe `db` instance passed to `subscriber.init()` is the key to subscriber getting information about:\n\n* what plans are available\n* what free trials are offered\n* what usage the current user has\n* what plan the current user is on\n* whether or not the current user plan is a free trial\n* when the current user's plan expires\n\nThe combination of all of the above allows subscriber to determine whether or not the user is permitted to perform the action s/he wants.\n\nsubscriber expects the `db` to have two asynchronous methods: `plans()` and `user()`\n\n#### Plans\n`db.plans(callback)` should retrieve all of the known plans with their limits, as well as trial information, and then pass them to the `callback`. The `callback` has the standard `expressjs`-style signature:\n\n    callback(err,data)\n\n`data` is a JS object composed of two parts:\n\n* `trial`: Object/Integer. Optional. information about free trials available on all plans.\n* `plans`: Array of plan objects. Required. Each object can have as many extraneous properties as it wants, but *must* have at least:\n* * `name`: the name of the plan. String.\n* * *`item`*: for each item limited, a key in the name of the item limited, and the value of an integer of the limit.\n\nIf there is no free trial offered, you can simplify the response by just returning the array of plans.\n\nExamples: \n\n1. No trial, just plans\n\n    `{plans:[{name:\"free\",clients:3,groups:2},{name:\"bronze\",clients:5,groups:10}]}`\n\t\t\n2. No trial, just plans (simpler form)\n\n    `[{name:\"free\",clients:3,groups:2},{name:\"bronze\",clients:5,groups:10}]`\n\t\t\n3. Free trial and plans\n\n    `{trial:14,plans:[{name:\"free\",clients:3,groups:2},{name:\"bronze\",clients:5,groups:10}]}`\n\n\nIn these examples, anyone in the \"free\" plan can have 3 clients and 2 groups, while anyone in the \"bronze\" plan can have 5 clients and 10 groups.\n\nIf this is the entire set of plans, then the only limits are on *creating* a new client or group, i.e. `POST /.../groups`. What about other actions? \n\n##### All Limits\nIn all cases, a limit value means:\n\n* positive integer (e.g. `10`): that number and no more\n* zero (`0`): none allowed, this action is blocked in this plan\n* `null` or `undefined`: unlimited number allowed\n\n##### Form of a plan\nEach plan object in the returned array must have the following properties:\n\n* `name`: String. Required. The name of the plan. This is never shown to the end-user (unless you choose to do so), but is used to relate the plan a user is on to the limits of the plan.\n* `limits`: Object. Optional. The limits for each resource type.\n\nEach key of `limits` represents an action with limits, e.g. `clients` above, and the value should be an object giving the action and limits. Here is an example:\n\n````JavaScript\n{name:\"bronze\",clients:{\n\t\"index\": null\n\t\"show\":10,\n\t\"create\": 3,\n\t\"update\": null\n}}\n````\n\nIn this example, users in the \"bronze\" plan can update (with `PUT`) or list all of their objects as many times as they want, but are limited to 10 \"show\" - normally `GET /api/clients/:client` - and 3 creations - normally `POST /api/clients`.\n\n\n##### \"create\" Shorthand\nBecause the most common restriction is creating items, there is a shorthand to limit creation:\n\n    {name:\"bronze\", limits:{groups:10}}\n\t\t\nCan create no more than 10 groups. All other actions are unrestricted. This is equivalent to:\n\n````JavaScript\n{name:\"bronze\",limits:{groups:{\n\tcreate:10\n}}}\n````\n\nBut shorter is better, right?\n\n##### Even shorter hand\nIf you have no `limits` property, then *all* properties of the plan itself - except the reserved \"name\" property - will be treated as limits:\n\n````JavaScript\n{name:\"bronze\",groups:{\n\tcreate:10\n}}\n````\n\nor even\n\n````JavaScript\n{name:\"bronze\",groups:10}\n````\n\n\n##### Path to Resource\nOf course, for subscriber to know that the request is creating a \"clients\", it needs to know how to match a path to a \"clients\". It knows it is a \"create\" because the request method is `POST`, but how does it know if `/api/clients` or `/api/clients10` or `/foo/bar/client/25/me` is the path you `POST` to to create a \"clients\"?\n\nThe two configuration options to subscriber - `base` and `paths` - determine this.\n\nAs usual, there is the default, and the explicit. \n\n1. Default: If no `paths` are given, then the path to each resource is simply `base+name`. Since `base` defaults to '/', then passing no parameters means that \"clients\" will be at `/clients` and `/clients/:client`.\n2. Base: If you don't want to give explicit paths for each item, but they are not at the root of '/', then you can still override it with the `base` parameter. For example, an option of `{base:'/api'}` means \"clients\" will be at `/api/clients` and `/api/clients/:client`.\n3. Paths: If you prefer, you can give explicit paths, as `{paths:{clients:'/foo/path/to/clients'}}` which will create paths at `/foo/path/to/clients` and `/foo/path/to/clients/:client`. Any resource *not* explicitly listed will fall back to the default.\n4. Base+Paths: If you list both, then it will combine them. Resources without paths will be added to the `base`; resources with absolute paths will be taken as is; resources with relative paths will be added to the `base`.\n\nHere are some examples. In all cases, the plan returned is `{name:\"bronze\",clients:10, groups:20}`\n\n\n###### Nothing\n\nWill look at the following paths:\n````\nGET /clients\nGET /clients/:client\nPUT /clients/:client\nPOST /clients\nPATCH /clients/:client\nDELETE /clients/:client\nGET /groups\nGET /groups/:group\nPUT /groups/:group\nPOST /groups\nPATCH /groups/:group\nDELETE /groups/:group\n````\n\n###### Base\n\n````JavaScript\nsubscriber.init({base:'/api'}); // or '/api/', since subscriber intelligently manages the trailing slash\n````\nWill look at the following paths:\n\n````\nGET /api/clients\nGET /api/clients/:client\nPUT /api/clients/:client\nPOST /api/clients\nPATCH /api/clients/:client\nDELETE /api/clients/:client\nGET /api/groups\nGET /api/groups/:group\nPUT /api/groups/:group\nPOST /api/groups\nPATCH /api/groups/:group\nDELETE /api/groups/:group\n````\n\n######  Paths\n\n\n````JavaScript\nsubscriber.init({paths:{\n\tclients: \"/foo/path/to/clients\"\n}});\n````\n\nNote that there is no path given for groups, so it defaults:\n\n````\nGET /foo/path/to/clients\nGET /foo/path/to/clients/:client\nPUT /foo/path/to/clients/:client\nPOST /foo/path/to/clients\nPATCH /foo/path/to/clients/:client\nDELETE /foo/path/to/clients/:client\nGET /groups\nGET /groups/:group\nPUT /groups/:group\nPOST /groups\nPATCH /groups/:group\nDELETE /groups/:group\n````\n\n###### Base+Paths\n\n````JavaScript\nsubscriber.init({base:'/api',paths:{\n\tclients: \"/my/clients\",\n\tgroups: \"some/groups\"\n}});\n````\n\nNote that \"groups\" have a relative path, so `base` is prepended, while `clients` have an absolute path.\n\n````\nGET /my/clients\nGET /my/clients/:client\nPUT /my/clients/:client\nPOST /my/clients\nPATCH /my/clients/:client\nDELETE /my/clients/:client\nGET /api/some/groups\nGET /api/some/groups/:group\nPUT /api/some/groups/:group\nPOST /api/some/groups\nPATCH /api/some/groups/:group\nDELETE /api/some/groups/:group\n````\n\n\n##### Free trial\nIf a free trial option is provided in `plans`, then users can have a free trial of any plan.\n\nThe trial option is provide as part of the response to `plans()` as follows:\n\n````JavaScript\n{trial:{duration:14,fallback:\"free\"},plans:[{name:\"free\",groups:2},{name:\"premium\",groups:5},{name:\"pro\",groups:10}]}\n````\n\nThe value of trial is, quite simply, the length in days of the free trial. In the above example, a user can get a free trial of the \"premium\" or \"pro\" plan for 14 days, after which they will fall back to the \"free\" plan. \n\nIf you don't want the user to have any fallback - i.e. after the free trial, they get no plan at all - then eliminate the \"fallback\" property:\n\n````JavaScript\n{trial:{duration:14},plans:[{name:\"premium\",groups:5},{name:\"pro\",groups:10}]}\n````\n\nWhich can be short-handed as:\n\n````JavaScript\n{trial:14,plans:[{name:\"premium\",groups:5},{name:\"pro\",groups:10}]}\n````\n\n\n\n#### User\nThe other activity for which `db` is responsible is telling `subscriber` all it needs to know about a user: how many of something it already *has*.\n\n````JavaScript\ndb.user(\"john\",function(err,res){\n\t// res is, e.g. {name:\"john\",plan:{name:\"free\",join:1234567,expire:1238899},usage:{clients:3,groups:2}}\n}); \n````\n\nsubscriber will `get` \"john\", and receive back what usage \"john\" actually has right now. In our example above, he already has 3 clients and 2 groups.\n\nThe \"user\" object has the following properties:\n\n\n* name: String. Required. Name of the user:\n* plan: Object / String. Required. Properties of the user's current plan, or just name of the plan (see plan shorthand below).\n* usage: Optional. What usage the user currently has, or nothing (see usage shorthand below).\n\n##### User plan\nThe \"plan\" property is an object with the following properties:\n\n* name: String. Required. Name of the plan.\n* trial: boolean. Optional. If `true`, then this person is in a free trial. Defaults to `false`.\n* join: Integer. Required. Date of the person joining the plan, as an integer (given by `Date.getTime()`)\n* expire: Integer. Optional. Date of the person's plan expiring, as an integer (given by `Date.getTime()`)\n\nIf you do not want to track when the user joined the plan, when his current plan expires, and if it is a trial, you can use the following shorthand:\n\n````JavaScript\n{name:\"john\",plan:\"free\",usage:{clients:3,groups:2}}\n````\n\n##### User usage\nThe \"usage\" property is an object. Each key is the name of a resource that is protected by subscriber; each value is the integer of the current usage of this user.\n\n````JavaScript\n{name:\"john\",plan:\"free\",usage:{clients:3,groups:2}}\n````\n\nUser \"john\" has 3 resources of type \"clients\" and 2 of type \"groups\". \n\nThere is also a shorthand version you can use, in which there is *no* property \"usage\". In that case, *every* property of the \"user\" object will be treated as a resource, except for reserved words \"usage\", \"name\", \"plan\".\n\n````JavaScript\n{name:\"john\",plan:\"free\",clients:3,groups:2}\n````\n\n\n\n##### Who is the user?\nHow does subscriber know which user is logged in, and thus which \"name\" to pass as the first argument to `db.user()`? It looks at `req.user` using the following logic:\n\n1. If req.user is a string, use that, e.g. `req.user = \"john\"` will lead to `db.user(\"john\",callback)`\n2. If req.user is an object, use `req.user.id`, e.g. `req.user.id = \"john\" will lead to `db.user(\"john\",callback)`\n3. If req.user is `null` or `undefined`, there is no user\n\n\n##### Free trial\nIf your system offers free trials, then the `user` object needs to have additional information about how this user signed up for the trial.\n\n````JavaScript\n{name:\"john\",plan:{name:\"pro\",join:1234567,expire:1238899,trial:true},usage:{clients:3,groups:2}}\n````\n\nWhen the user is no longer in a free trial, then \"trial\" should be set to `false` or simply deleted. \n\n\n\n#### Putting it Together\nLet's use a real example. \"john\" is logged in and wants to create a new client. subscriber sees the request. If plans are already loaded and not timed out, it goes straight to checking its plans in cache, else it loads them again:\n\n````JavaScript\ndb.plans(function(err,res){\n\t// res is:\n\t[\n\t{name:\"free\",clients:3},\n\t{name:\"bronze\",clients:5}\n\t]\t\n});\n````\n\nAs soon as \"john\" makes his `POST /clients` request, subscriber retrieves all of the information about \"john\":\n\n````JavaScript\ndb.user(\"john\",function(err,res){\n\t// res is:\n\t{name:\"john\",plan:\"free\",clients:3,groups:2}\n}); \n````\n\n\"john\" is on the plan named \"free\", and he has 3 clients. Checking the plans, we see that the \"free\" plan allows a maximum of 3 clients. \"john\" has hit his limit, and his request to add another \"client\" will have a response of `403`. \n\n\n### Responses\n\n#### Success\nIf the request succeeds, subscriber just calls `next()` and passes it on to your next route. subscriber becomes completely transparent.\n\n#### Failure\nIf the request hits a limit, subscriber will send back a `403`, which is the appropriate error code for a request that is unauthorized.\n\nThe body of the response will detail the failure in JSON:\n\n````JavaScript\n{reason:\"subscription\",plan:\"free\",item:\"clients\",maximum:3}\n````\n\nIt gives the reason for the failure (a subscription limit), the plan the user is on, the item that exceeded the limits, and the maximum allowed under the plan.\n\n\n# Licensing\nsubscriber is released under the MIT License http://www.opensource.org/licenses/mit-license.php\n\n# Author\nAvi Deitcher https://github.com/deitch",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/deitch/subscriber.git"
  },
  "scripts": {
    "test": "node_modules/.bin/mocha"
  },
  "url": "http://github.com/deitch/subscriber",
  "version": "0.3.1"
}
